
timer3_project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000011a  00800200  0000053e  000005d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000053e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  0080031a  0080031a  000006ec  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000006ec  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000071c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e8  00000000  00000000  0000075c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000012a2  00000000  00000000  00000844  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d75  00000000  00000000  00001ae6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000815  00000000  00000000  0000285b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000024c  00000000  00000000  00003070  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000687  00000000  00000000  000032bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000634  00000000  00000000  00003943  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b8  00000000  00000000  00003f77  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	65 c0       	rjmp	.+202    	; 0xcc <__ctors_end>
   2:	00 00       	nop
   4:	80 c0       	rjmp	.+256    	; 0x106 <__bad_interrupt>
   6:	00 00       	nop
   8:	7e c0       	rjmp	.+252    	; 0x106 <__bad_interrupt>
   a:	00 00       	nop
   c:	7c c0       	rjmp	.+248    	; 0x106 <__bad_interrupt>
   e:	00 00       	nop
  10:	9d c1       	rjmp	.+826    	; 0x34c <__vector_4>
  12:	00 00       	nop
  14:	78 c0       	rjmp	.+240    	; 0x106 <__bad_interrupt>
  16:	00 00       	nop
  18:	76 c0       	rjmp	.+236    	; 0x106 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	74 c0       	rjmp	.+232    	; 0x106 <__bad_interrupt>
  1e:	00 00       	nop
  20:	4e c1       	rjmp	.+668    	; 0x2be <__vector_8>
  22:	00 00       	nop
  24:	70 c0       	rjmp	.+224    	; 0x106 <__bad_interrupt>
  26:	00 00       	nop
  28:	6e c0       	rjmp	.+220    	; 0x106 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	6c c0       	rjmp	.+216    	; 0x106 <__bad_interrupt>
  2e:	00 00       	nop
  30:	6a c0       	rjmp	.+212    	; 0x106 <__bad_interrupt>
  32:	00 00       	nop
  34:	68 c0       	rjmp	.+208    	; 0x106 <__bad_interrupt>
  36:	00 00       	nop
  38:	66 c0       	rjmp	.+204    	; 0x106 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	64 c0       	rjmp	.+200    	; 0x106 <__bad_interrupt>
  3e:	00 00       	nop
  40:	62 c0       	rjmp	.+196    	; 0x106 <__bad_interrupt>
  42:	00 00       	nop
  44:	60 c0       	rjmp	.+192    	; 0x106 <__bad_interrupt>
  46:	00 00       	nop
  48:	5e c0       	rjmp	.+188    	; 0x106 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	5c c0       	rjmp	.+184    	; 0x106 <__bad_interrupt>
  4e:	00 00       	nop
  50:	5a c0       	rjmp	.+180    	; 0x106 <__bad_interrupt>
  52:	00 00       	nop
  54:	58 c0       	rjmp	.+176    	; 0x106 <__bad_interrupt>
  56:	00 00       	nop
  58:	56 c0       	rjmp	.+172    	; 0x106 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	54 c0       	rjmp	.+168    	; 0x106 <__bad_interrupt>
  5e:	00 00       	nop
  60:	52 c0       	rjmp	.+164    	; 0x106 <__bad_interrupt>
  62:	00 00       	nop
  64:	50 c0       	rjmp	.+160    	; 0x106 <__bad_interrupt>
  66:	00 00       	nop
  68:	4e c0       	rjmp	.+156    	; 0x106 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	4c c0       	rjmp	.+152    	; 0x106 <__bad_interrupt>
  6e:	00 00       	nop
  70:	4a c0       	rjmp	.+148    	; 0x106 <__bad_interrupt>
  72:	00 00       	nop
  74:	48 c0       	rjmp	.+144    	; 0x106 <__bad_interrupt>
  76:	00 00       	nop
  78:	46 c0       	rjmp	.+140    	; 0x106 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	44 c0       	rjmp	.+136    	; 0x106 <__bad_interrupt>
  7e:	00 00       	nop
  80:	42 c0       	rjmp	.+132    	; 0x106 <__bad_interrupt>
  82:	00 00       	nop
  84:	40 c0       	rjmp	.+128    	; 0x106 <__bad_interrupt>
  86:	00 00       	nop
  88:	3e c0       	rjmp	.+124    	; 0x106 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	3c c0       	rjmp	.+120    	; 0x106 <__bad_interrupt>
  8e:	00 00       	nop
  90:	3a c0       	rjmp	.+116    	; 0x106 <__bad_interrupt>
  92:	00 00       	nop
  94:	38 c0       	rjmp	.+112    	; 0x106 <__bad_interrupt>
  96:	00 00       	nop
  98:	36 c0       	rjmp	.+108    	; 0x106 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	34 c0       	rjmp	.+104    	; 0x106 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	32 c0       	rjmp	.+100    	; 0x106 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	30 c0       	rjmp	.+96     	; 0x106 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	2e c0       	rjmp	.+92     	; 0x106 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	2c c0       	rjmp	.+88     	; 0x106 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	2a c0       	rjmp	.+84     	; 0x106 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	28 c0       	rjmp	.+80     	; 0x106 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	26 c0       	rjmp	.+76     	; 0x106 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	8d c1       	rjmp	.+794    	; 0x3d8 <__vector_47>
  be:	00 00       	nop
  c0:	22 c0       	rjmp	.+68     	; 0x106 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	20 c0       	rjmp	.+64     	; 0x106 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	1e c0       	rjmp	.+60     	; 0x106 <__bad_interrupt>
	...

000000cc <__ctors_end>:
  cc:	11 24       	eor	r1, r1
  ce:	1f be       	out	0x3f, r1	; 63
  d0:	cf ef       	ldi	r28, 0xFF	; 255
  d2:	d1 e2       	ldi	r29, 0x21	; 33
  d4:	de bf       	out	0x3e, r29	; 62
  d6:	cd bf       	out	0x3d, r28	; 61

000000d8 <__do_copy_data>:
  d8:	13 e0       	ldi	r17, 0x03	; 3
  da:	a0 e0       	ldi	r26, 0x00	; 0
  dc:	b2 e0       	ldi	r27, 0x02	; 2
  de:	ee e3       	ldi	r30, 0x3E	; 62
  e0:	f5 e0       	ldi	r31, 0x05	; 5
  e2:	00 e0       	ldi	r16, 0x00	; 0
  e4:	0b bf       	out	0x3b, r16	; 59
  e6:	02 c0       	rjmp	.+4      	; 0xec <__do_copy_data+0x14>
  e8:	07 90       	elpm	r0, Z+
  ea:	0d 92       	st	X+, r0
  ec:	aa 31       	cpi	r26, 0x1A	; 26
  ee:	b1 07       	cpc	r27, r17
  f0:	d9 f7       	brne	.-10     	; 0xe8 <__do_copy_data+0x10>

000000f2 <__do_clear_bss>:
  f2:	23 e0       	ldi	r18, 0x03	; 3
  f4:	aa e1       	ldi	r26, 0x1A	; 26
  f6:	b3 e0       	ldi	r27, 0x03	; 3
  f8:	01 c0       	rjmp	.+2      	; 0xfc <.do_clear_bss_start>

000000fa <.do_clear_bss_loop>:
  fa:	1d 92       	st	X+, r1

000000fc <.do_clear_bss_start>:
  fc:	ab 31       	cpi	r26, 0x1B	; 27
  fe:	b2 07       	cpc	r27, r18
 100:	e1 f7       	brne	.-8      	; 0xfa <.do_clear_bss_loop>
 102:	d9 d1       	rcall	.+946    	; 0x4b6 <main>
 104:	1a c2       	rjmp	.+1076   	; 0x53a <_exit>

00000106 <__bad_interrupt>:
 106:	7c cf       	rjmp	.-264    	; 0x0 <__vectors>

00000108 <prescaler_set5>:
	}
}

void prescaler_set5(uint8_t num)
{
	if (num==1)
 108:	81 30       	cpi	r24, 0x01	; 1
 10a:	31 f4       	brne	.+12     	; 0x118 <prescaler_set5+0x10>
	{
		TCCR5B |= _BV(CS50);
 10c:	e1 e2       	ldi	r30, 0x21	; 33
 10e:	f1 e0       	ldi	r31, 0x01	; 1
 110:	80 81       	ld	r24, Z
 112:	81 60       	ori	r24, 0x01	; 1
 114:	80 83       	st	Z, r24
 116:	08 95       	ret
	}
	else if (num==8)
 118:	88 30       	cpi	r24, 0x08	; 8
 11a:	31 f4       	brne	.+12     	; 0x128 <prescaler_set5+0x20>
	{
		TCCR5B |= _BV(CS51);
 11c:	e1 e2       	ldi	r30, 0x21	; 33
 11e:	f1 e0       	ldi	r31, 0x01	; 1
 120:	80 81       	ld	r24, Z
 122:	82 60       	ori	r24, 0x02	; 2
 124:	80 83       	st	Z, r24
 126:	08 95       	ret
	}
	else if (num==64)
 128:	80 34       	cpi	r24, 0x40	; 64
 12a:	29 f4       	brne	.+10     	; 0x136 <prescaler_set5+0x2e>
	{
		TCCR5B |= _BV(CS51) | _BV(CS50);
 12c:	e1 e2       	ldi	r30, 0x21	; 33
 12e:	f1 e0       	ldi	r31, 0x01	; 1
 130:	80 81       	ld	r24, Z
 132:	83 60       	ori	r24, 0x03	; 3
 134:	80 83       	st	Z, r24
 136:	08 95       	ret

00000138 <fnd_write>:
 * arguments
 *  - fnd_num: FND number (2 ~ 0)
 * -------------------------------------------------------------------------- */
inline void fnd_clear(uint8_t fnd_num)
{
    fnd_write(fnd_num, 0);
 138:	9f b7       	in	r25, 0x3f	; 63
 13a:	f8 94       	cli
 13c:	84 bb       	out	0x14, r24	; 20
 13e:	68 b9       	out	0x08, r22	; 8
 140:	87 e0       	ldi	r24, 0x07	; 7
 142:	84 bb       	out	0x14, r24	; 20
 144:	99 23       	and	r25, r25
 146:	0c f4       	brge	.+2      	; 0x14a <fnd_write+0x12>
 148:	78 94       	sei
 14a:	08 95       	ret

0000014c <fnd_clear_all>:
/* ----------------------------------------------------------------------------
 * clear all FNDs 
 * -------------------------------------------------------------------------- */
void fnd_clear_all(void)
{
    fnd_write(0, 0);
 14c:	60 e0       	ldi	r22, 0x00	; 0
 14e:	80 e0       	ldi	r24, 0x00	; 0
 150:	f3 df       	rcall	.-26     	; 0x138 <fnd_write>
    fnd_write(1, 0);
 152:	60 e0       	ldi	r22, 0x00	; 0
 154:	81 e0       	ldi	r24, 0x01	; 1
 156:	f0 df       	rcall	.-32     	; 0x138 <fnd_write>
    fnd_write(2, 0);
 158:	60 e0       	ldi	r22, 0x00	; 0
 15a:	82 e0       	ldi	r24, 0x02	; 2
 15c:	ed cf       	rjmp	.-38     	; 0x138 <fnd_write>
 15e:	08 95       	ret

00000160 <fnd_write_number>:
{
    static uint8_t num_code[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x27, 0x7f, 0x6f,
                                  0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71};
    uint8_t value;
    
    value = num_code[num] | (dot_on<<7);
 160:	e6 2f       	mov	r30, r22
 162:	f0 e0       	ldi	r31, 0x00	; 0
 164:	e7 5f       	subi	r30, 0xF7	; 247
 166:	fc 4f       	sbci	r31, 0xFC	; 252
    fnd_write(fnd_num, value);    
 168:	90 e8       	ldi	r25, 0x80	; 128
 16a:	49 9f       	mul	r20, r25
 16c:	a0 01       	movw	r20, r0
 16e:	11 24       	eor	r1, r1
 170:	60 81       	ld	r22, Z
 172:	64 2b       	or	r22, r20
 174:	e1 cf       	rjmp	.-62     	; 0x138 <fnd_write>
 176:	08 95       	ret

00000178 <fnd_write_numbers>:
}

void fnd_write_numbers(uint16_t num)
{
 178:	0f 93       	push	r16
 17a:	1f 93       	push	r17
 17c:	cf 93       	push	r28
 17e:	df 93       	push	r29
 180:	8c 01       	movw	r16, r24
	uint16_t a = num%10;
 182:	9c 01       	movw	r18, r24
 184:	ad ec       	ldi	r26, 0xCD	; 205
 186:	bc ec       	ldi	r27, 0xCC	; 204
 188:	c9 d1       	rcall	.+914    	; 0x51c <__umulhisi3>
 18a:	fc 01       	movw	r30, r24
 18c:	f6 95       	lsr	r31
 18e:	e7 95       	ror	r30
 190:	f6 95       	lsr	r31
 192:	e7 95       	ror	r30
 194:	f6 95       	lsr	r31
 196:	e7 95       	ror	r30
 198:	cf 01       	movw	r24, r30
 19a:	88 0f       	add	r24, r24
 19c:	99 1f       	adc	r25, r25
 19e:	ee 0f       	add	r30, r30
 1a0:	ff 1f       	adc	r31, r31
 1a2:	ee 0f       	add	r30, r30
 1a4:	ff 1f       	adc	r31, r31
 1a6:	ee 0f       	add	r30, r30
 1a8:	ff 1f       	adc	r31, r31
 1aa:	e8 0f       	add	r30, r24
 1ac:	f9 1f       	adc	r31, r25
 1ae:	c8 01       	movw	r24, r16
 1b0:	8e 1b       	sub	r24, r30
 1b2:	9f 0b       	sbc	r25, r31
 1b4:	fc 01       	movw	r30, r24
	uint16_t b = (num/10)%10;
 1b6:	b2 d1       	rcall	.+868    	; 0x51c <__umulhisi3>
 1b8:	ac 01       	movw	r20, r24
 1ba:	56 95       	lsr	r21
 1bc:	47 95       	ror	r20
 1be:	56 95       	lsr	r21
 1c0:	47 95       	ror	r20
 1c2:	56 95       	lsr	r21
 1c4:	47 95       	ror	r20
 1c6:	9a 01       	movw	r18, r20
 1c8:	a9 d1       	rcall	.+850    	; 0x51c <__umulhisi3>
 1ca:	ec 01       	movw	r28, r24
 1cc:	d6 95       	lsr	r29
 1ce:	c7 95       	ror	r28
 1d0:	d6 95       	lsr	r29
 1d2:	c7 95       	ror	r28
 1d4:	d6 95       	lsr	r29
 1d6:	c7 95       	ror	r28
 1d8:	ce 01       	movw	r24, r28
 1da:	88 0f       	add	r24, r24
 1dc:	99 1f       	adc	r25, r25
 1de:	cc 0f       	add	r28, r28
 1e0:	dd 1f       	adc	r29, r29
 1e2:	cc 0f       	add	r28, r28
 1e4:	dd 1f       	adc	r29, r29
 1e6:	cc 0f       	add	r28, r28
 1e8:	dd 1f       	adc	r29, r29
 1ea:	c8 0f       	add	r28, r24
 1ec:	d9 1f       	adc	r29, r25
 1ee:	ca 01       	movw	r24, r20
 1f0:	8c 1b       	sub	r24, r28
 1f2:	9d 0b       	sbc	r25, r29
 1f4:	ec 01       	movw	r28, r24
 1f6:	0a 30       	cpi	r16, 0x0A	; 10
	uint16_t c = (num/100)%10;
	
	if(num<10)
 1f8:	11 05       	cpc	r17, r1
 1fa:	58 f4       	brcc	.+22     	; 0x212 <fnd_write_numbers+0x9a>
 1fc:	40 e0       	ldi	r20, 0x00	; 0
	{
		fnd_write_number(0,a,0);
 1fe:	6e 2f       	mov	r22, r30
 200:	80 e0       	ldi	r24, 0x00	; 0
 202:	ae df       	rcall	.-164    	; 0x160 <fnd_write_number>
		fnd_write(1,0);
 204:	60 e0       	ldi	r22, 0x00	; 0
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	97 df       	rcall	.-210    	; 0x138 <fnd_write>
		fnd_write(2,0);
 20a:	60 e0       	ldi	r22, 0x00	; 0
 20c:	82 e0       	ldi	r24, 0x02	; 2
 20e:	94 df       	rcall	.-216    	; 0x138 <fnd_write>
 210:	3d c0       	rjmp	.+122    	; 0x28c <fnd_write_numbers+0x114>
 212:	04 36       	cpi	r16, 0x64	; 100
	}
	else if(num<100)
 214:	11 05       	cpc	r17, r1
 216:	60 f4       	brcc	.+24     	; 0x230 <fnd_write_numbers+0xb8>
	{
		fnd_write_number(0,a,0);
 218:	40 e0       	ldi	r20, 0x00	; 0
 21a:	6e 2f       	mov	r22, r30
 21c:	80 e0       	ldi	r24, 0x00	; 0
 21e:	a0 df       	rcall	.-192    	; 0x160 <fnd_write_number>
		fnd_write_number(1,b,0);
 220:	40 e0       	ldi	r20, 0x00	; 0
 222:	6c 2f       	mov	r22, r28
 224:	81 e0       	ldi	r24, 0x01	; 1
 226:	9c df       	rcall	.-200    	; 0x160 <fnd_write_number>
		fnd_write(2,0);
 228:	60 e0       	ldi	r22, 0x00	; 0
 22a:	82 e0       	ldi	r24, 0x02	; 2
 22c:	85 df       	rcall	.-246    	; 0x138 <fnd_write>
 22e:	2e c0       	rjmp	.+92     	; 0x28c <fnd_write_numbers+0x114>
	}
	else
	{
		fnd_write_number(0,a,0);
 230:	40 e0       	ldi	r20, 0x00	; 0
 232:	6e 2f       	mov	r22, r30
 234:	80 e0       	ldi	r24, 0x00	; 0
 236:	94 df       	rcall	.-216    	; 0x160 <fnd_write_number>
 238:	40 e0       	ldi	r20, 0x00	; 0
		fnd_write_number(1,b,0);
 23a:	6c 2f       	mov	r22, r28
 23c:	81 e0       	ldi	r24, 0x01	; 1
 23e:	90 df       	rcall	.-224    	; 0x160 <fnd_write_number>
 240:	98 01       	movw	r18, r16
		fnd_write_number(2,c,0);
 242:	36 95       	lsr	r19
 244:	27 95       	ror	r18
 246:	36 95       	lsr	r19
 248:	27 95       	ror	r18
 24a:	ab e7       	ldi	r26, 0x7B	; 123
 24c:	b4 e1       	ldi	r27, 0x14	; 20
 24e:	66 d1       	rcall	.+716    	; 0x51c <__umulhisi3>
 250:	ac 01       	movw	r20, r24
 252:	56 95       	lsr	r21
 254:	47 95       	ror	r20
 256:	9a 01       	movw	r18, r20
 258:	ad ec       	ldi	r26, 0xCD	; 205
 25a:	bc ec       	ldi	r27, 0xCC	; 204
 25c:	5f d1       	rcall	.+702    	; 0x51c <__umulhisi3>
 25e:	96 95       	lsr	r25
 260:	87 95       	ror	r24
 262:	96 95       	lsr	r25
 264:	87 95       	ror	r24
 266:	96 95       	lsr	r25
 268:	87 95       	ror	r24
 26a:	9c 01       	movw	r18, r24
 26c:	22 0f       	add	r18, r18
 26e:	33 1f       	adc	r19, r19
 270:	88 0f       	add	r24, r24
 272:	99 1f       	adc	r25, r25
 274:	88 0f       	add	r24, r24
 276:	99 1f       	adc	r25, r25
 278:	88 0f       	add	r24, r24
 27a:	99 1f       	adc	r25, r25
 27c:	82 0f       	add	r24, r18
 27e:	93 1f       	adc	r25, r19
 280:	ba 01       	movw	r22, r20
 282:	68 1b       	sub	r22, r24
 284:	79 0b       	sbc	r23, r25
 286:	40 e0       	ldi	r20, 0x00	; 0
 288:	82 e0       	ldi	r24, 0x02	; 2
 28a:	6a df       	rcall	.-300    	; 0x160 <fnd_write_number>
 28c:	df 91       	pop	r29
 28e:	cf 91       	pop	r28
	}
	
}
 290:	1f 91       	pop	r17
 292:	0f 91       	pop	r16
 294:	08 95       	ret

00000296 <led_write>:
 296:	9f b7       	in	r25, 0x3f	; 63
 298:	f8 94       	cli
 * arguments
 *  - fnd_num: FND number (2 ~ 0)
 * -------------------------------------------------------------------------- */
inline static void fnd_select(uint8_t fnd_num)
{
    PORTG = fnd_num;
 29a:	23 e0       	ldi	r18, 0x03	; 3
 29c:	24 bb       	out	0x14, r18	; 20
    
    sreg = SREG;            // save SREG
    cli();                  // disable interrupt to prevent shared-data problem

    fnd_select(3);
    PORTC = value;
 29e:	88 b9       	out	0x08, r24	; 8
/* ----------------------------------------------------------------------------
 * deselect selected FND
 * -------------------------------------------------------------------------- */
inline static void fnd_deselect(void)
{
    PORTG = 0x07;
 2a0:	87 e0       	ldi	r24, 0x07	; 7
 2a2:	84 bb       	out	0x14, r24	; 20

    fnd_select(3);
    PORTC = value;
    fnd_deselect();

    if(sreg&0x80)           // if global interrupt was enabled before executing cli()
 2a4:	99 23       	and	r25, r25
 2a6:	0c f4       	brge	.+2      	; 0x2aa <led_write+0x14>
        sei();              // enable interrupt        
 2a8:	78 94       	sei
 2aa:	08 95       	ret

000002ac <fnd_init>:
 * initialize port for FND/LED interface
 * -------------------------------------------------------------------------- */
inline static void fnd_port_init(void)
{
    // configure output
    DDRC = 0xff;            // PORTC[7..0]
 2ac:	8f ef       	ldi	r24, 0xFF	; 255
 2ae:	87 b9       	out	0x07, r24	; 7
    DDRG = 0x07;            // PORTG[2..0]
 2b0:	87 e0       	ldi	r24, 0x07	; 7
 2b2:	83 bb       	out	0x13, r24	; 19
    DDRB |= _BV(LED_COLOR);
 2b4:	24 9a       	sbi	0x04, 4	; 4
 * initialize FND/LED
 * -------------------------------------------------------------------------- */
void fnd_init(void)
{
    fnd_port_init();
    fnd_clear_all();
 2b6:	4a df       	rcall	.-364    	; 0x14c <fnd_clear_all>
    led_write(0xff);
 2b8:	8f ef       	ldi	r24, 0xFF	; 255
 2ba:	ed cf       	rjmp	.-38     	; 0x296 <led_write>
 2bc:	08 95       	ret

000002be <__vector_8>:
static uint8_t i = 255;
static uint16_t fnd_num = 0;
static uint8_t a = 0;

ISR(INT7_vect)
{
 2be:	1f 92       	push	r1
 2c0:	0f 92       	push	r0
 2c2:	0f b6       	in	r0, 0x3f	; 63
 2c4:	0f 92       	push	r0
 2c6:	11 24       	eor	r1, r1
 2c8:	0b b6       	in	r0, 0x3b	; 59
 2ca:	0f 92       	push	r0
 2cc:	2f 93       	push	r18
 2ce:	3f 93       	push	r19
 2d0:	4f 93       	push	r20
 2d2:	5f 93       	push	r21
 2d4:	6f 93       	push	r22
 2d6:	7f 93       	push	r23
 2d8:	8f 93       	push	r24
 2da:	9f 93       	push	r25
 2dc:	af 93       	push	r26
 2de:	bf 93       	push	r27
 2e0:	ef 93       	push	r30
 2e2:	ff 93       	push	r31
	if (a<100)
 2e4:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <__data_end>
 2e8:	84 36       	cpi	r24, 0x64	; 100
 2ea:	20 f4       	brcc	.+8      	; 0x2f4 <__vector_8+0x36>
	{
		a = a + 10;
 2ec:	86 5f       	subi	r24, 0xF6	; 246
 2ee:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <__data_end>
 2f2:	03 c0       	rjmp	.+6      	; 0x2fa <__vector_8+0x3c>
	}
	else
	{
		a = 100;
 2f4:	84 e6       	ldi	r24, 0x64	; 100
 2f6:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <__data_end>
	}
	fnd_write_numbers(a);
 2fa:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <__data_end>
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	3b df       	rcall	.-394    	; 0x178 <fnd_write_numbers>
	OCR5A = (F_CPU/(8*256*4))-1;
}

void set_timer3_dutycycle(uint8_t dutycycle)
{
	OCR3A = 10 * dutycycle;
 302:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <__data_end>
 306:	90 e0       	ldi	r25, 0x00	; 0
 308:	9c 01       	movw	r18, r24
 30a:	22 0f       	add	r18, r18
 30c:	33 1f       	adc	r19, r19
 30e:	88 0f       	add	r24, r24
 310:	99 1f       	adc	r25, r25
 312:	88 0f       	add	r24, r24
 314:	99 1f       	adc	r25, r25
 316:	88 0f       	add	r24, r24
 318:	99 1f       	adc	r25, r25
 31a:	82 0f       	add	r24, r18
 31c:	93 1f       	adc	r25, r19
 31e:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
 322:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	{
		a = 100;
	}
	fnd_write_numbers(a);
	set_timer3_dutycycle(a);
}
 326:	ff 91       	pop	r31
 328:	ef 91       	pop	r30
 32a:	bf 91       	pop	r27
 32c:	af 91       	pop	r26
 32e:	9f 91       	pop	r25
 330:	8f 91       	pop	r24
 332:	7f 91       	pop	r23
 334:	6f 91       	pop	r22
 336:	5f 91       	pop	r21
 338:	4f 91       	pop	r20
 33a:	3f 91       	pop	r19
 33c:	2f 91       	pop	r18
 33e:	0f 90       	pop	r0
 340:	0b be       	out	0x3b, r0	; 59
 342:	0f 90       	pop	r0
 344:	0f be       	out	0x3f, r0	; 63
 346:	0f 90       	pop	r0
 348:	1f 90       	pop	r1
 34a:	18 95       	reti

0000034c <__vector_4>:

ISR(INT3_vect)
{
 34c:	1f 92       	push	r1
 34e:	0f 92       	push	r0
 350:	0f b6       	in	r0, 0x3f	; 63
 352:	0f 92       	push	r0
 354:	11 24       	eor	r1, r1
 356:	0b b6       	in	r0, 0x3b	; 59
 358:	0f 92       	push	r0
 35a:	2f 93       	push	r18
 35c:	3f 93       	push	r19
 35e:	4f 93       	push	r20
 360:	5f 93       	push	r21
 362:	6f 93       	push	r22
 364:	7f 93       	push	r23
 366:	8f 93       	push	r24
 368:	9f 93       	push	r25
 36a:	af 93       	push	r26
 36c:	bf 93       	push	r27
 36e:	ef 93       	push	r30
 370:	ff 93       	push	r31
	if(a>0)
 372:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <__data_end>
 376:	88 23       	and	r24, r24
 378:	21 f0       	breq	.+8      	; 0x382 <__vector_4+0x36>
	{
		a = a - 10;
 37a:	8a 50       	subi	r24, 0x0A	; 10
 37c:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <__data_end>
 380:	02 c0       	rjmp	.+4      	; 0x386 <__vector_4+0x3a>
	}
	else
	{
		a = 0;
 382:	10 92 1a 03 	sts	0x031A, r1	; 0x80031a <__data_end>
	}
	
	fnd_write_numbers(a);
 386:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <__data_end>
 38a:	90 e0       	ldi	r25, 0x00	; 0
 38c:	f5 de       	rcall	.-534    	; 0x178 <fnd_write_numbers>
	OCR5A = (F_CPU/(8*256*4))-1;
}

void set_timer3_dutycycle(uint8_t dutycycle)
{
	OCR3A = 10 * dutycycle;
 38e:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <__data_end>
 392:	90 e0       	ldi	r25, 0x00	; 0
 394:	9c 01       	movw	r18, r24
 396:	22 0f       	add	r18, r18
 398:	33 1f       	adc	r19, r19
 39a:	88 0f       	add	r24, r24
 39c:	99 1f       	adc	r25, r25
 39e:	88 0f       	add	r24, r24
 3a0:	99 1f       	adc	r25, r25
 3a2:	88 0f       	add	r24, r24
 3a4:	99 1f       	adc	r25, r25
 3a6:	82 0f       	add	r24, r18
 3a8:	93 1f       	adc	r25, r19
 3aa:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
 3ae:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
		a = 0;
	}
	
	fnd_write_numbers(a);
	set_timer3_dutycycle(a);
}
 3b2:	ff 91       	pop	r31
 3b4:	ef 91       	pop	r30
 3b6:	bf 91       	pop	r27
 3b8:	af 91       	pop	r26
 3ba:	9f 91       	pop	r25
 3bc:	8f 91       	pop	r24
 3be:	7f 91       	pop	r23
 3c0:	6f 91       	pop	r22
 3c2:	5f 91       	pop	r21
 3c4:	4f 91       	pop	r20
 3c6:	3f 91       	pop	r19
 3c8:	2f 91       	pop	r18
 3ca:	0f 90       	pop	r0
 3cc:	0b be       	out	0x3b, r0	; 59
 3ce:	0f 90       	pop	r0
 3d0:	0f be       	out	0x3f, r0	; 63
 3d2:	0f 90       	pop	r0
 3d4:	1f 90       	pop	r1
 3d6:	18 95       	reti

000003d8 <__vector_47>:

ISR(TIMER5_COMPA_vect)
{
 3d8:	1f 92       	push	r1
 3da:	0f 92       	push	r0
 3dc:	0f b6       	in	r0, 0x3f	; 63
 3de:	0f 92       	push	r0
 3e0:	11 24       	eor	r1, r1
 3e2:	0b b6       	in	r0, 0x3b	; 59
 3e4:	0f 92       	push	r0
 3e6:	8f 93       	push	r24
 3e8:	ef 93       	push	r30
 3ea:	ff 93       	push	r31
	i++;
 3ec:	e0 91 00 02 	lds	r30, 0x0200	; 0x800200 <__data_start>
 3f0:	ef 5f       	subi	r30, 0xFF	; 255
 3f2:	e0 93 00 02 	sts	0x0200, r30	; 0x800200 <__data_start>
	OCR2A = signal_table[i];
 3f6:	f0 e0       	ldi	r31, 0x00	; 0
 3f8:	ef 5f       	subi	r30, 0xFF	; 255
 3fa:	fd 4f       	sbci	r31, 0xFD	; 253
 3fc:	80 81       	ld	r24, Z
 3fe:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
}
 402:	ff 91       	pop	r31
 404:	ef 91       	pop	r30
 406:	8f 91       	pop	r24
 408:	0f 90       	pop	r0
 40a:	0b be       	out	0x3b, r0	; 59
 40c:	0f 90       	pop	r0
 40e:	0f be       	out	0x3f, r0	; 63
 410:	0f 90       	pop	r0
 412:	1f 90       	pop	r1
 414:	18 95       	reti

00000416 <ioport_init>:
}

void ioport_init(void)
{
	//DDRC의 하위 4bit을 출력하는 단자로 만든다.
	DDRC = _BV(LED1) | _BV(LED2) | _BV(LED3) | _BV(LED4);
 416:	8f e0       	ldi	r24, 0x0F	; 15
 418:	87 b9       	out	0x07, r24	; 7
	//MCU의 LED보드 4개의 불을 끈다.
	PORTC = 0xff;
 41a:	8f ef       	ldi	r24, 0xFF	; 255
 41c:	88 b9       	out	0x08, r24	; 8
	PORTE = _BV(SW2);
 41e:	80 e8       	ldi	r24, 0x80	; 128
 420:	8e b9       	out	0x0e, r24	; 14
	PORTD = _BV(SW3);
 422:	88 e0       	ldi	r24, 0x08	; 8
 424:	8b b9       	out	0x0b, r24	; 11
	DDRE = _BV(SOUND_OUT);
 426:	8d b9       	out	0x0d, r24	; 13
	DDRB = _BV(LED_COLOR);
 428:	80 e1       	ldi	r24, 0x10	; 16
 42a:	84 b9       	out	0x04, r24	; 4
 42c:	08 95       	ret

0000042e <interrupt_init>:
}

void interrupt_init(void)
{
	// 하강 모서리 (falling edge)에서 INT3이발생하도록 EICRA를설정한다.
	EICRA = _BV(ISC31);
 42e:	80 e8       	ldi	r24, 0x80	; 128
 430:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <__TEXT_REGION_LENGTH__+0x7e0069>
	// 하강 모서리 (falling edge)에서 INT7이발생하도록 EICRB를설정한다.
	EICRB = _BV(ISC71);
 434:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__TEXT_REGION_LENGTH__+0x7e006a>
	// INT7와 INT3을 enable시킨다.
	EIMSK = _BV(INT7) | _BV(INT3);
 438:	88 e8       	ldi	r24, 0x88	; 136
 43a:	8d bb       	out	0x1d, r24	; 29
	//timer5번의 compare match interrupt enable.
	TIMSK5 = _BV(OCIE5A);
 43c:	82 e0       	ldi	r24, 0x02	; 2
 43e:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x7e0073>
	// global interrupt flag을 set시킨다.
	sei();
 442:	78 94       	sei
 444:	08 95       	ret

00000446 <timer_init>:
}
void timer_init(void)
{
	// Timer2를 Fast PWM 모드로 동작시키고 PWM 신호는 OC2A 핀으로출력하려고한다.
	TCCR2A |= _BV(WGM21) | _BV(WGM20);
 446:	e0 eb       	ldi	r30, 0xB0	; 176
 448:	f0 e0       	ldi	r31, 0x00	; 0
 44a:	80 81       	ld	r24, Z
 44c:	83 60       	ori	r24, 0x03	; 3
 44e:	80 83       	st	Z, r24
	// 이 때 prescaler는 1로 설정하고
	TCCR2B |= _BV(CS20);
 450:	a1 eb       	ldi	r26, 0xB1	; 177
 452:	b0 e0       	ldi	r27, 0x00	; 0
 454:	8c 91       	ld	r24, X
 456:	81 60       	ori	r24, 0x01	; 1
 458:	8c 93       	st	X, r24
	//COM2A1 비트와 COM2A0 비트는각각 1과 0으로설정한다.
	TCCR2A |= _BV(COM2A1);
 45a:	80 81       	ld	r24, Z
 45c:	80 68       	ori	r24, 0x80	; 128
 45e:	80 83       	st	Z, r24
	// 출력 PWM의 duty cycle이 50 %가 되도록 OCR2A 레지스터값을설정한다.
	OCR2A = 50*(2*255)/(2*100);
 460:	8f e7       	ldi	r24, 0x7F	; 127
 462:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
	
	// Timer3을 Phase Correct PWM 모드로 동작시키고 PWM 신호는 OC3A 핀으로출력하려고한다
	TCCR3A |= _BV(WGM31);
 466:	e0 e9       	ldi	r30, 0x90	; 144
 468:	f0 e0       	ldi	r31, 0x00	; 0
 46a:	80 81       	ld	r24, Z
 46c:	82 60       	ori	r24, 0x02	; 2
 46e:	80 83       	st	Z, r24
	TCCR3B |= _BV(WGM33);
 470:	a1 e9       	ldi	r26, 0x91	; 145
 472:	b0 e0       	ldi	r27, 0x00	; 0
 474:	8c 91       	ld	r24, X
 476:	80 61       	ori	r24, 0x10	; 16
 478:	8c 93       	st	X, r24
	// prescaler를 8로 설정하고
	TCCR3B |= _BV(CS31);
 47a:	8c 91       	ld	r24, X
 47c:	82 60       	ori	r24, 0x02	; 2
 47e:	8c 93       	st	X, r24
	//COM3A1 비트와 COM3A0 비트는각각 1과 0으로설정한다.
	TCCR3A |= _BV(COM3A1);
 480:	80 81       	ld	r24, Z
 482:	80 68       	ori	r24, 0x80	; 128
 484:	80 83       	st	Z, r24
	// PWM 주파수가 1 KHz가 되도록 하려면 ICR3 레지스터에값을저장한다.
	ICR3 = F_CPU/(2*8*1000);
 486:	88 ee       	ldi	r24, 0xE8	; 232
 488:	93 e0       	ldi	r25, 0x03	; 3
 48a:	90 93 97 00 	sts	0x0097, r25	; 0x800097 <__TEXT_REGION_LENGTH__+0x7e0097>
 48e:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <__TEXT_REGION_LENGTH__+0x7e0096>
	// 출력 PWM의 duty cycle이 50 %가 되도록 OCR3A 레지스터값을설정한다.
	OCR3A = 0;
 492:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
 496:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	
	// Timer5을 CTC 모드로 설정
	TCCR5B |= _BV(WGM52);
 49a:	e1 e2       	ldi	r30, 0x21	; 33
 49c:	f1 e0       	ldi	r31, 0x01	; 1
 49e:	80 81       	ld	r24, Z
 4a0:	88 60       	ori	r24, 0x08	; 8
 4a2:	80 83       	st	Z, r24
	// 이 때 prescaler는 8로 설정한다
	prescaler_set5(8);
 4a4:	88 e0       	ldi	r24, 0x08	; 8
 4a6:	30 de       	rcall	.-928    	; 0x108 <prescaler_set5>
	// 256×4 Hz의주파수로 compare match interrupt가발생하도록설정한다.
	OCR5A = (F_CPU/(8*256*4))-1;
 4a8:	80 ea       	ldi	r24, 0xA0	; 160
 4aa:	97 e0       	ldi	r25, 0x07	; 7
 4ac:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x7e0129>
 4b0:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x7e0128>
 4b4:	08 95       	ret

000004b6 <main>:
	i++;
	OCR2A = signal_table[i];
}

int main(void)
{
 4b6:	cf 93       	push	r28
 4b8:	df 93       	push	r29
 4ba:	cd b7       	in	r28, 0x3d	; 61
 4bc:	de b7       	in	r29, 0x3e	; 62
 4be:	28 97       	sbiw	r28, 0x08	; 8
 4c0:	0f b6       	in	r0, 0x3f	; 63
 4c2:	f8 94       	cli
 4c4:	de bf       	out	0x3e, r29	; 62
 4c6:	0f be       	out	0x3f, r0	; 63
 4c8:	cd bf       	out	0x3d, r28	; 61
	ioport_init();
 4ca:	a5 df       	rcall	.-182    	; 0x416 <ioport_init>
	timer_init();
 4cc:	bc df       	rcall	.-136    	; 0x446 <timer_init>
	interrupt_init();
 4ce:	af df       	rcall	.-162    	; 0x42e <interrupt_init>
 4d0:	ed de       	rcall	.-550    	; 0x2ac <fnd_init>
	fnd_init();
 4d2:	80 e0       	ldi	r24, 0x00	; 0
	
	fnd_write_numbers(fnd_num);
 4d4:	90 e0       	ldi	r25, 0x00	; 0
 4d6:	50 de       	rcall	.-864    	; 0x178 <fnd_write_numbers>
 4d8:	88 e0       	ldi	r24, 0x08	; 8
 4da:	e1 e0       	ldi	r30, 0x01	; 1
	
	uint8_t led_pattern[8] = {0x81, 0xC3, 0xE7, 0xFF, 0x7E, 0x3C, 0x18, 0x00};
 4dc:	f3 e0       	ldi	r31, 0x03	; 3
 4de:	de 01       	movw	r26, r28
 4e0:	11 96       	adiw	r26, 0x01	; 1
 4e2:	01 90       	ld	r0, Z+
 4e4:	0d 92       	st	X+, r0
 4e6:	8a 95       	dec	r24
 4e8:	e1 f7       	brne	.-8      	; 0x4e2 <main+0x2c>
 4ea:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
	
	/* Replace with your application code */
	while (1)
	{
		led_write(led_pattern[i++%8]);
 4ee:	91 e0       	ldi	r25, 0x01	; 1
 4f0:	98 0f       	add	r25, r24
 4f2:	90 93 00 02 	sts	0x0200, r25	; 0x800200 <__data_start>
 4f6:	87 70       	andi	r24, 0x07	; 7
 4f8:	e1 e0       	ldi	r30, 0x01	; 1
 4fa:	f0 e0       	ldi	r31, 0x00	; 0
 4fc:	ec 0f       	add	r30, r28
 4fe:	fd 1f       	adc	r31, r29
 500:	e8 0f       	add	r30, r24
 502:	f1 1d       	adc	r31, r1
 504:	80 81       	ld	r24, Z
 506:	c7 de       	rcall	.-626    	; 0x296 <led_write>
 508:	2f ef       	ldi	r18, 0xFF	; 255
 50a:	84 e3       	ldi	r24, 0x34	; 52
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 50c:	9c e0       	ldi	r25, 0x0C	; 12
 50e:	21 50       	subi	r18, 0x01	; 1
 510:	80 40       	sbci	r24, 0x00	; 0
 512:	90 40       	sbci	r25, 0x00	; 0
 514:	e1 f7       	brne	.-8      	; 0x50e <main+0x58>
 516:	00 c0       	rjmp	.+0      	; 0x518 <main+0x62>
 518:	00 00       	nop
 51a:	e7 cf       	rjmp	.-50     	; 0x4ea <main+0x34>

0000051c <__umulhisi3>:
 51c:	a2 9f       	mul	r26, r18
 51e:	b0 01       	movw	r22, r0
 520:	b3 9f       	mul	r27, r19
 522:	c0 01       	movw	r24, r0
 524:	a3 9f       	mul	r26, r19
 526:	70 0d       	add	r23, r0
 528:	81 1d       	adc	r24, r1
 52a:	11 24       	eor	r1, r1
 52c:	91 1d       	adc	r25, r1
 52e:	b2 9f       	mul	r27, r18
 530:	70 0d       	add	r23, r0
 532:	81 1d       	adc	r24, r1
 534:	11 24       	eor	r1, r1
 536:	91 1d       	adc	r25, r1
 538:	08 95       	ret

0000053a <_exit>:
 53a:	f8 94       	cli

0000053c <__stop_program>:
 53c:	ff cf       	rjmp	.-2      	; 0x53c <__stop_program>
